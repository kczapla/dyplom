__author__ = 'perun'

# import networkx as nx
import core.networks as nw
import core.test as test
import core.devices as dev


class Data:
    def __init__(self):

        """
        Method initialize interests matrix for 3 class of flow, list of creted by user networks and index to handle
        operations on networks.

        """
        self.interest_matrix_voice = []
        self.interest_matrix_video = []
        self.interest_matrix_be = []
        self.networks = []
        self.index = 0

        self.index_nodes = 0
        self.index_links = 0
        self.nodes = []
        self.links = []

        self.adjacency_matrix = []
        self.connections = []
        self.paths_matrix = []
        self.paths = []

    # Methods connected with displaying Data class
    def process_data(self):

        for nets in self.networks:
            nets.reset_resources()

        self.split_matrix()

        if self.interest_matrix_voice:
            for nets in self.networks:
                if 'GSM' in nets.name:
                    nets.set_intensity_voice_out(self.networks)

            for nets in self.networks:
                if 'GSM' in nets.name:
                    nets.input_resources()
                    nets.output_resources()

            for nets in self.networks:
                nets.set_flow_voice_in(self.networks)

            for nets in self.networks:
                nets.set_flow_voice_out(self.networks)

        for nets in self.networks:
            if not 'GSM' in nets.name:
                if self.interest_matrix_video:
                    nets.set_flow_video_in(self.networks)
                if self.interest_matrix_be:
                    nets.set_flow_be_in(self.networks)

        for nets in self.networks:
            if not 'GSM' in nets.name:
                if self.interest_matrix_video:
                    nets.set_flow_video_out(self.networks)
                if self.interest_matrix_be:
                    nets.set_flow_be_out(self.networks)

    def show_data(self):
        for x in self.networks:
            print("+++++++++++++++++")
            for y in (x.__dict__.keys()):
                print("{} = {}".format(y, x.__dict__[y]))
            print("+++++++++++++++++")

    def use_test_values(self):
        self.interest_matrix_voice = test.interest_matrix
        self.interest_matrix_video = test.intrest_matrix_video
        self.interest_matrix_be = test.interest_matrix_be
        for tmp in test.test_networks():
            self.networks.append(tmp)
            self.index = test.index

            # Methods connected with processing Data class

    def create_circuit_network(self, intensity=0, loss=0):

        """
        Method is adding new circuit network, with values set by user, to the row of networks
        :param intensity: Intensity generated by network
        :param loss: loss probability
        """
        self.networks.append(nw.Circuit(self.index, intensity, loss))
        self.index += 1

    def create_package_network(self, intensity_voice=0, intensity_video=0, intensity_be=0):

        """
        Method is adding new package network, with values set by user, to the row of networks
        :param intensity_video: Video stream intensity generated by network
        :param intensity_be: BE stream intensity generated by network
        :param intensity_voice: Voice stream intensity generated by network
        """

        self.networks.append(nw.Package(self.index, intensity_voice, intensity_video, intensity_be))
        self.index += 1

    def delete_network(self, n=None):

        """
        Method is deleting selected network from the row of created networks. It also removes the row from an interest
        matrix belonging to deleted network. Finally it reorganise index of existing networks and reprocess data.
        :param n: Index of network to delete
        """
        self.networks.pop(n)
        self.index -= 1

        for x in range(self.index):
            self.networks[x].set_index(x)

            if self.interest_matrix_voice:
                self.interest_matrix_voice[x].pop(n)
            if self.interest_matrix_video:
                self.interest_matrix_video[x].pop(n)
            if self.interest_matrix_be:
                self.interest_matrix_be[x].pop(n)

        if self.interest_matrix_voice:
            self.interest_matrix_voice.pop(n)

        if self.interest_matrix_video:
            self.interest_matrix_video.pop(n)

        if self.interest_matrix_be:
            self.interest_matrix_be.pop(n)

    def create_interest_matrix(self, interest_matrix):

        """
        Creating the interest matrix based on the number of networks
        """
        interest_matrix = list()
        interest_matrix.append(
            [[float(input('x[{}][{}] = '.format(ly, lx))) for ly in range(self.index)] for lx in range(self.index)])

    def split_matrix(self):

        """
        Method which partial interest matrix into row to every network
        :return: set the value of interest_row_voice in instance of the network class
        """
        for temp in self.networks:
            if self.interest_matrix_voice:
                temp.interest_row_voice = self.interest_matrix_voice[temp.index]

            if self.interest_matrix_video:
                temp.interest_row_video = self.interest_matrix_video[temp.index]

            if self.interest_matrix_be:
                temp.interest_row_be = self.interest_matrix_be[temp.index]

    @staticmethod
    def change_single_value_matrix(row, col, interest_matrix=None):

        """

        :param row: row where variable is
        :param col: column where variable is
        :param interest_matrix: which matrix change
        """
        interest_matrix[row][col] = float(input('New value: '))

    # methods connected with graph operations
    def create_node_edge(self, buffer_voice, buffer_video, buffer_be):

        """

        :param buffer_voice: size of queue for voice traffic
        :param buffer_video: size of queue for video traffic
        :param buffer_be: size of queue for best effort traffic
        """
        self.nodes.append(dev.EdgeRouter(self.index_nodes, buffer_voice, buffer_video, buffer_be))
        self.index_nodes += 1

    def create_node_core(self, buffer_voice, buffer_video, buffer_be):

        """

        :param buffer_voice: size of queue for voice traffic
        :param buffer_video: size of queue for video traffic
        :param buffer_be: size of queue for best effort traffic
        """
        self.nodes.append(dev.CoreRouter(self.index_nodes, buffer_voice, buffer_video, buffer_be))
        self.index_nodes += 1

    def delete_node(self, index):

        self.nodes.pop(index)
        self.index_nodes -= 1

        # self.nodes = [self.nodes[x].set_name(x) for x in range(self.index_nodes)]
        for x in range(self.index_nodes):
            self.nodes[x].set_name(x)

        if self.adjacency_matrix:
            for x in self.adjacency_matrix:
                x.pop(index)

            self.adjacency_matrix.pop(index)
            self.slice_adjacency_matrix()
            self.create_links()

    def create_links(self):

        """
        Method is creating links between nodes
        """
        self.links = []
        # self.links = [dev.Link(x, int(input('Length: ')), int(input('Capacity: '))) for x in self.connections_sliced]
        self.links = [dev.Link(x, 50, 300) for x in self.connections]
        # self.links.append(dev.Link(index, length, capacity))

    def create_adjacency_matrix(self):

        """
        Creating a splitting adjacency matrix.
        bug - self.adjacency_matrix.index(x) returns '1' when matrix [[0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0],
        [1, 0, 0, 0]] because this method is looking for first appearance of the value to appear. First is on the first
        row. Be aware of it!

        """
        self.adjacency_matrix = []
        # self.adjacency_matrix = ([[int(input('x[{}][{}] = '.format(lx, ly))) for ly in range(self.index_nodes)]
        # for lx in range(self.index_nodes)])
        self.adjacency_matrix = [[0, 1, 0, 1, 1, 0], [1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0],
                                 [1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0]]
        self.slice_adjacency_matrix()

    def slice_adjacency_matrix(self):

        self.connections = [[self.adjacency_matrix.index(x), i] for x in self.adjacency_matrix
                            for i, j in enumerate(x) if j == 1]

        for x in self.connections:
            for y in self.connections:
                tmp = y[:]
                tmp.reverse()
                if tmp == x:
                    self.connections.remove(y)

    def create_paths_matrix(self):

        self.paths_matrix = []
        # self.paths_matrix = ([[int(input('x[{}][{}] = '.format(lx, ly))) for ly in range(self.index_nodes)]
        # for lx in range(self.index_nodes)])
        self.paths_matrix = [[5, 2, 1, 0], [0, 1, 3, 2, 5]]

        self.slice_paths_matrix()

    def slice_paths_matrix(self):

        self.paths = [[] for x in self.paths_matrix]

        for x in self.path_matrix:
            for y in range(len(x)):
                if y < len(x)-1:
                    self.paths[self.paths_matrix.index(x)].append(x[y:y+2])

    def scatter_flow(self):

        for x in self.networks:
            for y in self.nodes:
                if 'ER' in y.name and not y.connected:
                    y.flow_voice = x.flow_voice_in
                    y.flow_video = x.flow_video_in
                    y.flow_be = x.flow_be_in
                    y.set_connected(True)

        

if __name__ == '__main__':

    d = Data()
    for x in range(3):
        d.create_node_core(5, 15, 30)
    for x in range(3):
        d.create_node_edge(5, 15, 30)

    d.create_adjacency_matrix()
    print(d.adjacency_matrix)
    d.create_links()

    for x in d.links:
        print(x.name)

    d.delete_node(3)

    for x in d.nodes:
        print(x.name)

    for x in d.links:
        print(x.name)
        # print(d.connections)
        #print(d.connections_sliced)