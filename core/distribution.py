__author__ = 'perun'

# import networkx as nx
import core.networks as nw
import core.test as test
import core.devices as dev
import core.calculations


class Data:
    def __init__(self):
        """
        Method initialize interests matrix for 3 class of flow, list of created by user networks
        and index_networks to handle operations on networks.
        """
        self.interest_matrix_voice = []
        self.interest_matrix_video = []
        self.interest_matrix_be = []
        self.networks = []
        self.index_networks = 0

        self.index_nodes = 0
        self.index_links = 0
        self.nodes = []
        self.links = []

        self.adjacency_matrix = []
        self.connections = []

        self.paths_matrix = []
        self.paths = []

        self.paths_matrix_voice = []
        self.paths_voice = []

        self.paths_matrix_video = []
        self.paths_video = []

        self.paths_matrix_be = []
        self.paths_be = []

        # variable have list with networks connected to core network
        self.net_edge = []

        self.iplr_for_paths_voice = {}
        self.iplr_for_paths_video = {}
        self.iplr_for_paths_be = {}

        self.ipdt_for_paths_voice = {}
        self.ipdt_for_paths_video = {}
        self.ipdt_for_paths_be = {}

        self.ipdv_for_paths_voice = {}
        self.ipdv_for_paths_video = {}
        self.ipdv_for_paths_be = {}

        self.is_flow = False

        self.avg_voice_package_length = 0
        self.avg_video_package_length = 0
        self.avg_be_package_length = 0

    # Methods connected with displaying Data class

    def process_data_resources(self):
        for nets in self.networks:
            nets.reset_resources()
        self.split_matrix()
        if self.interest_matrix_voice:
            for nets in self.networks:
                if type(nets) is nw.Circuit:
                    nets.set_intensity_voice_out(self.networks)
            for nets in self.networks:
                if type(nets) is nw.Circuit:
                    nets.input_resources()
                    nets.output_resources()
            for nets in self.networks:
                nets.set_flow_voice_in(self.networks)
            for nets in self.networks:
                nets.set_flow_voice_out(self.networks)
        else:
            print('Set  voice interest matrix')

        for nets in self.networks:
            if type(nets) is nw.Package:
                if self.interest_matrix_video:
                    nets.set_flow_video_in(self.networks)
                else:
                    print('Set video interest matrix')
                if self.interest_matrix_be:
                    nets.set_flow_be_in(self.networks)
                else:
                    print('Set be interest matrix')
        for nets in self.networks:
            if type(nets) is nw.Package:
                if self.interest_matrix_video:
                    nets.set_flow_video_out(self.networks)
                else:
                    print('Set video interest matrix')
                if self.interest_matrix_be:
                    nets.set_flow_be_out(self.networks)
                else:
                    print('Set be interest matrix')

        self.package_length()

    def process_data_flow(self):
        self.set_connections()

        self.scatter_flow_voice()

        if self.interest_matrix_video:
            self.scatter_flow_video()
        else:
            print('Video interest matrix does not exists...')

        if self.interest_matrix_be:
            self.scatter_flow_be()
        else:
            print('BE interest matrix does not exists...')

        self.sum_up_flow()

        self.is_flow = True

    def process_data_qos(self):
        self.scatter_iplr()
        self.sum_iplr_path_voice()
        self.sum_iplr_path_video()
        self.sum_iplr_path_be()

        self.scatter_ipdt()
        self.sum_ipdt_path_voice()
        self.sum_ipdt_path_video()
        self.sum_ipdt_path_be()

        self.scatter_ipdv()
        self.sum_ipdv_path_voice()
        self.sum_ipdv_path_video()
        self.sum_ipdv_path_be()

    def show_data(self):
        for x in self.networks:
            print("+++++++++++++++++")
            for y in (x.__dict__.keys()):
                print("{} = {}".format(y, x.__dict__[y]))
            print("+++++++++++++++++")

    def use_test_values(self):
        self.interest_matrix_voice = test.interest_matrix
        self.interest_matrix_video = test.intrest_matrix_video
        self.interest_matrix_be = test.interest_matrix_be
        for tmp in test.test_networks():
            self.networks.append(tmp)
            self.index_networks = test.index

    # Methods connected with processing Data class

    def create_circuit_network(self, name, intensity=0, loss=0.0):
        """
        Method is adding new circuit network, with values set by user, to the networks' list
        :param intensity: Intensity generated by network
        :param loss: loss probability
        """
        self.networks.append(nw.Circuit(name, self.index_networks, intensity, loss))
        self.index_networks += 1

    def create_package_network(self, name, intensity_voice=0, intensity_video=0, intensity_be=0,
                               video_package_length=0, be_package_length=0):
        """
        Method is adding new package network, with values set by user, to the networks' list
        :param intensity_video: Video stream intensity generated by network
        :param intensity_be: BE stream intensity generated by network
        :param intensity_voice: Voice stream intensity generated by network
        """
        self.networks.append(nw.Package(name, self.index_networks, intensity_voice, intensity_video, intensity_be,
                                        video_package_length, be_package_length))
        self.index_networks += 1

    def edit_network(self, name, index, intensity_voice=0, intensity_video=0, intensity_be=0, loss=0,
                     video_package_length=0, be_package_length=0):
        """
        Setups new initiation values for existing circuit network selected by index
        :param intensity_video: new video intensity value
        :param intensity_be: new be intensity value
        :param index: index of network in networks list
        :param intensity_voice: new voice intensity value
        :param loss: new loss value
        """
        if type(self.networks[index]) is nw.Circuit:
            self.networks[index].edit_network(name, intensity_voice, loss)
        elif type(self.networks[index]) is nw.Package:
            self.networks[index].edit_network(name, intensity_voice, intensity_video, intensity_be,
                                              video_package_length, be_package_length)

    def delete_network(self, n=None):
        """
        Method is deleting selected network from the row of created networks. It also removes the row from an interest
        matrix belonging to deleted network. Finally it reorganise index_networks of existing networks and reprocess
        data.
        :param n: Index of network to delete
        """
        self.networks.pop(n)
        self.index_networks -= 1
        for x in range(self.index_networks):
            self.networks[x].set_index(x)
            if self.interest_matrix_voice:
                self.interest_matrix_voice[x].pop(n)
            if self.interest_matrix_video:
                self.interest_matrix_video[x].pop(n)
            if self.interest_matrix_be:
                self.interest_matrix_be[x].pop(n)
        if self.interest_matrix_voice:
            self.interest_matrix_voice.pop(n)
        if self.interest_matrix_video:
            self.interest_matrix_video.pop(n)
        if self.interest_matrix_be:
            self.interest_matrix_be.pop(n)

    def package_length(self):
        """
        Method is calculating average length of packages in the core network. It's counting number

        """
        print('Calculating average packages\' lengths in the core network')
        # voice traffic variables
        no_g711 = 0
        no_g729 = 0
        no_all = 0
        g711_length = self.networks[0].package_length_g711
        g729_length = self.networks[0].package_length_g729

        # video traffic variables
        no_video_all = 0

        # be traffic variables
        no_be_all = 0

        for network in self.networks:
            no_g711 += network.no_voice_package_g711
            no_all += network.no_voice_package_g711

            no_g729 += network.no_voice_package_g729
            no_all += network.no_voice_package_g729

            if type(network) is core.networks.Package:
                no_video_all += network.no_video_package
                no_be_all += network.no_be_package
            #if network.chosen_voice_codec == 'g.711':
            #    no_g711 += network.no_voice_package
            #    no_all += network.no_voice_package
            #
            #    if type(network) is core.networks.Package:
            #        no_video_all += network.no_video_package
            #        no_be_all += network.no_be_package
            #
            #elif network.chosen_voice_codec == 'g.729':
            #    no_g729 += network.no_voice_package
            #    no_all += network.no_voice_package
            #
            #    if type(network) is core.networks.Package:
            #        no_video_all += network.no_video_package
            #        no_be_all += network.no_be_package

        video_package_lengths = []
        video_package_probabilities = []

        be_package_lengths = []
        be_package_probabilities = []

        for network in self.networks:
            if type(network) is core.networks.Package:
                video_package_lengths.append(network.package_length_h264)
                if no_video_all > 0:
                    video_package_probabilities.append(network.no_video_package/no_video_all)
                    print('No video packages in the network...')

                be_package_lengths.append(network.package_length_be)
                if no_be_all > 0:
                    be_package_probabilities.append(network.no_be_package/no_be_all)
                    print('No be packages in the network...')

        voice_package_lengths = [g711_length, g729_length]
        voice_package_probabilities = [no_g711/no_all, no_g729/no_all]

        voice_avg = list(map(core.calculations.expected_value, voice_package_lengths, voice_package_probabilities))
        self.avg_voice_package_length = sum(voice_avg)

        if no_video_all > 0:
            video_avg = list(map(core.calculations.expected_value, video_package_lengths, video_package_probabilities))
            self.avg_video_package_length = sum(video_avg)
        else:
            self.avg_video_package_length = 0

        if no_be_all > 0:
            be_avg = list(map(core.calculations.expected_value, be_package_lengths, be_package_probabilities))
            self.avg_be_package_length = sum(be_avg)
        else:
            self.avg_be_package_length = 0

        print('Average voice package length: ', str(self.avg_voice_package_length))
        print('Average video package length: ', str(self.avg_video_package_length))
        print('Average be package length: ', str(self.avg_be_package_length))

    def set_interest_matrix_voice(self, matrix):
        """
        Creating the interest matrix based on the number of networks
        """
        self.interest_matrix_voice = list()
        self.interest_matrix_voice = matrix
        #self.split_matrix()

    def set_interest_matrix_video(self, matrix):
        """
        Creating the interest matrix based on the number of networks
        """
        self.interest_matrix_video = list()
        self.interest_matrix_video = matrix
        #self.split_matrix()

    def set_interest_matrix_be(self, matrix):
        """
        Creating the interest matrix based on the number of networks
        """
        self.interest_matrix_be = list()
        self.interest_matrix_be = matrix
        #self.split_matrix()

    def split_matrix(self):
        """
        Method which partial interest matrix into row to every network
        :return: set the value of interest_row_voice in instance of the network class
        """
        for temp in self.networks:
            if self.interest_matrix_voice:
                temp.interest_row_voice = self.interest_matrix_voice[temp.index]

            if self.interest_matrix_video:
                temp.interest_row_video = self.interest_matrix_video[temp.index]

            if self.interest_matrix_be:
                temp.interest_row_be = self.interest_matrix_be[temp.index]

    def change_single_value_interest_matrix_voice(self, index, row):
        """
        :param row: row where variable is
        """
        self.interest_matrix_voice[index] = row
        self.process_data_resources()

    def change_single_value_interest_matrix_video(self, index, row):
        self.interest_matrix_video[index] = row
        self.process_data_resources()

    def change_single_value_interest_matrix_be(self, index, row):
        self.interest_matrix_be[index] = row
        self.process_data_resources()

    # methods connected with graph operations
    def create_node_edge(self, name, buffer_voice, buffer_video, buffer_be):
        """

        :param name: new name
        :param buffer_voice: size of queue for voice traffic
        :param buffer_video: size of queue for video traffic
        :param buffer_be: size of queue for best effort traffic
        """
        self.nodes.append(dev.EdgeRouter(name, self.index_nodes, buffer_voice, buffer_video, buffer_be))
        self.index_nodes += 1

    def create_node_core(self, name, buffer_voice, buffer_video, buffer_be):
        """

        :param name: new name
        :param buffer_voice: size of queue for voice traffic
        :param buffer_video: size of queue for video traffic
        :param buffer_be: size of queue for best effort traffic
        """
        self.nodes.append(dev.CoreRouter(name, self.index_nodes, buffer_voice, buffer_video, buffer_be))
        self.index_nodes += 1

    def delete_node(self, index):
        self.nodes.pop(index)
        self.index_nodes -= 1
        for x in range(self.index_nodes):
            self.nodes[x].set_name(x)
        if self.adjacency_matrix:
            for x in self.adjacency_matrix:
                x.pop(index)
            self.adjacency_matrix.pop(index)
            self.slice_adjacency_matrix()
            self.create_links()

    def edit_node(self, name, index, buffer_voice, buffer_video, buffer_be):
        print('Edit router')
        self.nodes[index].edit(name, buffer_voice, buffer_video, buffer_be)

    def create_links(self):
        """
        Method is creating links between nodes based on connections implemented in adjacency matrix. Method is
        implementing every link with 0 value. User later have to edit link with demanding values.
        """
        self.links = [dev.Link('Link ({}, {})'.format(self.nodes[connection[0]].name, self.nodes[connection[1]].name),
                               connection, 0, 0) for connection in self.connections]

    def edit_link(self, name, index, length, capacity):
        """
        Method is responsible for editing single link.
        :param name: New name of link
        :param length: New length of link
        :param capacity: New capacity of link
        """
        self.links[index].edit(name, length, capacity)

    def create_adjacency_matrix(self, matrix):
        """
        Creating a splitting adjacency matrix.
        bug - self.adjacency_matrix.index_networks(x) returns '1' when matrix [[0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0],
        [1, 0, 0, 0]] because this method is looking for first appearance of the value to appear. First is on the first
        row. Be aware of it!
        """
        self.adjacency_matrix = []
        self.adjacency_matrix = matrix
        self.slice_adjacency_matrix()
        self.create_links()

    def slice_adjacency_matrix(self):
        self.connections = [[self.adjacency_matrix.index(x), i] for x in self.adjacency_matrix
                            for i, j in enumerate(x) if j == 1]
        for x in self.connections:
            for y in self.connections:
                tmp = y[:]
                tmp.reverse()
                if tmp == x:
                    self.connections.remove(y)

    def create_net_edge_matrix(self, matrix):
        self.net_edge = []
        self.net_edge = matrix

    def create_paths_matrix(self, matrix):
        #self.paths_matrix = []
        #self.paths_matrix = matrix
        #self.slice_paths_matrix()
        self.create_paths_matrix_voice(matrix)
        self.create_paths_matrix_video(matrix)
        self.create_paths_matrix_be(matrix)

    def slice_paths_matrix(self):
        self.paths = [[] for x in self.paths_matrix]
        for x in self.paths_matrix:
            for y in range(len(x)):
                if y < len(x) - 1:
                    self.paths[self.paths_matrix.index(x)].append(x[y:y + 2])

    def create_paths_matrix_voice(self, matrix):
        self.paths_matrix_voice = []
        self.paths_matrix_voice = matrix
        self.slice_paths_matrix_voice()

    def slice_paths_matrix_voice(self):
        self.paths_voice = [[] for x in self.paths_matrix_voice]
        for x in self.paths_matrix_voice:
            for y in range(len(x)):
                if y < len(x) - 1:
                    index = self.paths_matrix_voice.index(x)
                    self.paths_voice[index].append(x[y:y + 2])

    def create_paths_matrix_video(self, matrix):
        self.paths_matrix_video = []
        self.paths_matrix_video = matrix
        self.slice_paths_matrix_video()

    def slice_paths_matrix_video(self):
        self.paths_video = [[] for x in self.paths_matrix_video]
        for x in self.paths_matrix_video:
            for y in range(len(x)):
                if y < len(x) - 1:
                    self.paths_video[self.paths_matrix_video.index(x)].append(x[y:y + 2])

    def create_paths_matrix_be(self, matrix):
        self.paths_matrix_be = []
        self.paths_matrix_be = matrix
        self.slice_paths_matrix_be()

    def slice_paths_matrix_be(self):
        self.paths_be = [[] for x in self.paths_matrix_be]
        for x in self.paths_matrix_be:
            for y in range(len(x)):
                if y < len(x) - 1:
                    self.paths_be[self.paths_matrix_be.index(x)].append(x[y:y + 2])

    def set_connections(self):
        for x in self.net_edge:
            for y in self.networks:
                if x[0] == y.index:
                    for z in self.nodes:
                        if x[1] == z.index and type(z) is dev.EdgeRouter and not z.connected:
                        #if x[1] == z.index and 'ER' in z.name and not z.connected:
                            z.flow_voice = y.flow_voice_in

                            if type(y) is nw.Circuit:
                                z.flow_video = 0
                                z.flow_be = 0
                            elif type(y) is nw.Package:
                                z.flow_video = y.flow_video_in
                                z.flow_be = y.flow_be_in

                            z.set_connected(True, y.index)
                            break
                        else:
                            print('''Can\'t connect with that edge router. It doesn\'t exist or it is already connected
                                     with other network.''')

    def scatter_flow_voice(self):
        for x in self.paths_voice:
            node_source = self.nodes[x[0][0]]
            network_source_index = node_source.connected_index
            network_destination_index = self.nodes[x[-1][-1]].connected_index
            temporary_flow = self.networks[network_source_index].flow_voice_in_list[network_destination_index]

            for y in x:
                tmp = y[:]
                tmp.reverse()
                for z in self.links:
                    if y == z.index or tmp == z.index:

                        z.flow_voice_up += temporary_flow
                        # Writing the name of path going through link
                        z.paths_voice[str(x)] = temporary_flow
                        break

                    #elif tmp == z.index:
                    #    z.flow_voice_down += self.nodes[x[0][0]].flow_voice
                    #    # Writing the name of path going through link
                    #    z.paths_voice[str(x)] = self.nodes[x[0][0]].flow_voice
                    #    break

    def scatter_flow_video(self):
        for x in self.paths_video:
            node_source = self.nodes[x[0][0]]
            network_source_index = node_source.connected_index
            network_destination_index = self.nodes[x[-1][-1]].connected_index
            temporary_flow = self.networks[network_source_index].flow_video_in_list[network_destination_index]
            for y in x:
                tmp = y[:]
                tmp.reverse()
                for z in self.links:
                    if y == z.index or tmp == z.index:
                        z.flow_video_up += temporary_flow
                        # Writing the name of path going through link
                        z.paths_video[str(x)] = temporary_flow
                        break
                    #elif tmp == z.index:
                    #    z.flow_video_down += self.nodes[x[0][0]].flow_video
                    #    # Writing the name of path going through link
                    #    z.paths_video[str(x)] = self.nodes[x[0][0]].flow_video
                    #    break

    def scatter_flow_be(self):
        for x in self.paths_be:
            node_source = self.nodes[x[0][0]]
            network_source_index = node_source.connected_index
            network_destination_index = self.nodes[x[-1][-1]].connected_index
            temporary_flow = self.networks[network_source_index].flow_be_in_list[network_destination_index]

            for y in x:
                tmp = y[:]
                tmp.reverse()
                for z in self.links:
                    if y == z.index or tmp == z.index:
                        z.flow_be_up += temporary_flow
                        # Writing the name of path going through link
                        z.paths_be[str(x)] = temporary_flow
                        break
                    #elif tmp == z.index:
                    #    z.flow_be_down += self.nodes[x[0][0]].flow_be
                    #    # Writing the name of path going through link
                    #    z.paths_be[str(x)] = self.nodes[x[0][0]].flow_be
                    #    break

    def sum_up_flow(self):
        for x in self.links:
            x.set_flow_voice()
            x.set_flow_video()
            x.set_flow_be()

    def scatter_iplr(self):
        for link in self.links:
            link.calculate_iplr(self.nodes)

    def sum_iplr_path_voice(self):
        self.iplr_for_paths_voice = {}
        for path in self.paths_voice:
            self.iplr_for_paths_voice[str(path)] = 0
            tmp_iplr = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_iplr += y.iplr_voice
                        break
            self.iplr_for_paths_voice[str(path)] = tmp_iplr

    def sum_iplr_path_video(self):
        self.iplr_for_paths_video = {}
        for path in self.paths_video:
            self.iplr_for_paths_video[str(path)] = 0
            tmp_iplr = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_iplr += y.iplr_video
                        break
            self.iplr_for_paths_video[str(path)] = tmp_iplr

    def sum_iplr_path_be(self):
        self.iplr_for_paths_be = {}
        for path in self.paths_be:
            self.iplr_for_paths_be[str(path)] = 0
            tmp_iplr = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_iplr += y.iplr_be
                        break
            self.iplr_for_paths_be[str(path)] = tmp_iplr

    def scatter_ipdt(self):
        for link in self.links:
            link.calculate_ipdt(self.nodes, self.avg_voice_package_length, self.avg_video_package_length,
                                self.avg_be_package_length)

    def sum_ipdt_path_voice(self):
        self.ipdt_for_paths_voice = {}
        for path in self.paths_voice:
            self.ipdt_for_paths_voice[str(path)] = 0
            tmp_ipdt = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_ipdt += y.ipdt_voice
                        break
            self.ipdt_for_paths_voice[str(path)] = tmp_ipdt

    def sum_ipdt_path_video(self):
        self.ipdt_for_paths_video = {}
        for path in self.paths_video:
            self.ipdt_for_paths_video[str(path)] = 0
            tmp_ipdt = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_ipdt += y.ipdt_video
                        break
            self.ipdt_for_paths_video[str(path)] = tmp_ipdt

    def sum_ipdt_path_be(self):
        self.ipdt_for_paths_be = {}
        for path in self.paths_be:
            self.ipdt_for_paths_be[str(path)] = 0
            tmp_ipdt = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_ipdt += y.ipdt_be
                        break
            self.ipdt_for_paths_be[str(path)] = tmp_ipdt

    def scatter_ipdv(self):
        for link in self.links:
            link.calculate_ipdv(self.nodes, self.avg_voice_package_length, self.avg_video_package_length,
                                self.avg_be_package_length)

    def sum_ipdv_path_voice(self):
        self.ipdv_for_paths_voice = {}
        for path in self.paths_voice:
            self.ipdv_for_paths_voice[str(path)] = 0
            tmp_ipdv = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_ipdv += y.ipdv_voice
                        break
            self.ipdv_for_paths_voice[str(path)] = tmp_ipdv

    def sum_ipdv_path_video(self):
        self.ipdv_for_paths_video = {}
        for path in self.paths_video:
            self.ipdv_for_paths_video[str(path)] = 0
            tmp_ipdv = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_ipdv += y.ipdv_video
                        break
            self.ipdv_for_paths_video[str(path)] = tmp_ipdv

    def sum_ipdv_path_be(self):
        self.ipdv_for_paths_be = {}
        for path in self.paths_be:
            self.ipdv_for_paths_be[str(path)] = 0
            tmp_ipdv = 0
            for x in path:
                for y in self.links:
                    tmp = y.index[:]
                    tmp.reverse()
                    if y.index == x or tmp == x:
                        tmp_ipdv += y.ipdv_be
                        break
            self.ipdv_for_paths_be[str(path)] = tmp_ipdv

    def test(self):
        self.create_package_network('Ip1', 1000, 1000, 15000, 0, 1500)
        self.create_package_network('Ip2', 100, 1000, 16000, 0, 1500)
        #self.create_package_network('Test2', 50, 500, 500, 0, 1500)
        self.create_circuit_network('PSTN1', 180, 0.002)

        self.set_interest_matrix_voice([[0, 0.5, 0.5], [0.5, 0, 0.5], [0.5, 0.5, 0]])
        self.set_interest_matrix_video([[0, 0, 0], [0, 0, 0], [0, 0, 0]])
        self.set_interest_matrix_be([[0, 0.5, 0.5], [0.5, 0, 0.5], [0.5, 0.5, 0]])

        self.process_data_resources()

        self.create_node_edge('RB1', 5, 15, 30)
        self.create_node_edge('RB2', 5, 15, 30)
        self.create_node_edge('RB3', 5, 15, 30)
        for abc in range(3):
            self.create_node_core('RR' + str(abc), 5, 15, 30)

        self.create_adjacency_matrix([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1],
                                      [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])

        print(self.adjacency_matrix)

        #d.create_links()
        self.create_links()
        for link in self.links:
            self.edit_link('', self.links.index(link ), 50, 150000000)

        self.create_paths_matrix_voice([[0, 3, 5, 2], [2, 5, 3, 0], [1, 4, 5, 2], [2, 5, 4, 1], [1, 4, 3, 0],
                                        [0, 3, 4, 1]])

        self.create_paths_matrix_video([[0, 3, 5, 2], [2, 5, 3, 0], [1, 4, 5, 2], [2, 5, 4, 1], [1, 4, 3, 0],
                                        [0, 3, 4, 1]])
        self.create_paths_matrix_be([[0, 3, 5, 2], [2, 5, 3, 0], [1, 4, 5, 2], [2, 5, 4, 1], [1, 4, 3, 0],
                                     [0, 3, 4, 1]])

        self.create_net_edge_matrix([[0, 0], [1, 1], [2, 2]])
        self.set_connections()

        self.scatter_flow_voice()
        self.scatter_flow_video()
        self.scatter_flow_be()

        self.sum_up_flow()

        print('Natezenie dla sieci 2 ', self.networks[2].flow_voice_in)
        print('Voice package length: ', self.avg_voice_package_length)

        for link in self.links:
            print(link.paths_voice)
            print('Voice in link {}'.format(link.index), link.flow_voice)
            print(link.iplr_voice)
            print(link.ipdt_voice)
            print(link.ipdv_voice)

        self.scatter_iplr()
        self.sum_iplr_path_voice()
        self.sum_iplr_path_video()
        self.sum_iplr_path_be()
        #
        self.scatter_ipdt()
        self.sum_ipdt_path_voice()
        self.sum_ipdt_path_video()
        self.sum_ipdt_path_be()
        #
        self.scatter_ipdv()
        self.sum_ipdv_path_voice()
        self.sum_ipdv_path_video()
        self.sum_ipdv_path_be()
        #
        #for x in self.links:
        #    print(x.index)
        #    print(x.flow_voice_up)
        #    print(x.flow_voice_down)
        #    print(x.flow_voice)
        #    print(x.paths_voice)
        #    print('-----------------------')
        #    print('IPLR for voice: ', x.iplr_voice)
        #    print('IPLR for video: ', x.iplr_video)
        #    print('IPLR for be: ', x.iplr_be)
        #    print('------------------------')
        #    print('IPDT for voice: ', x.ipdt_voice)
        #    print('IPDT for video: ', x.ipdt_video)
        #    print('IPDT for be: ', x.ipdt_be)
        #    print('+++++++++++++++++++++++')
        #
        #print('Voice IPLR: ', d.iplr_for_paths_voice)
        #print('Video IPLR: ', d.iplr_for_paths_video)
        #print('BE IPLR: ', d.iplr_for_paths_be)
        #print('------------------------')
        #print('Voice IPDT: ', d.ipdt_for_paths_voice)
        #print('Video IPDT: ', d.ipdt_for_paths_video)
        #print('BE IPDT: ', d.ipdt_for_paths_be)
        #print('------------------------')
        #print('Voice IPDV: ', d.ipdv_for_paths_voice)
        #print('Video IPDV: ', d.ipdv_for_paths_video)
        #print('BE IPDV: ', d.ipdv_for_paths_be)
        #print(d.connections)
        for link in self.links:
            print(link.paths_voice)
            print('Voice in link {}'.format(link.index), link.flow_voice)
            print(link.iplr_voice)
            print(link.ipdt_voice)
            print(link.ipdv_voice)

    def test_no_2(self):
        self.create_circuit_network('adam', 240, 0.002)
        self.create_circuit_network('aaaa', 350, 0.002)
        #self.create_circuit_network('b', 180, 0.002)
        self.create_package_network('ccc', 10000, 100, 100, 100, 100)
        self.set_interest_matrix_voice([[0, 0.5, 0.5], [0.5, 0, 0.5], [0.5, 0.5, 0]])
        #self.create_package_network('ccc', 120, 200, 200, 100, 100)
        self.process_data_resources()
        print(self.networks[0].flow_voice_in_list)

        #for network in self.networks:
        #    if type(network) is core.networks.Circuit:
        #        network.input_resources()

        self.package_length()


    def test3(self):
        self.create_circuit_network('PSTN1', 240, 0.002)
        self.create_circuit_network('PSTN1', 350, 0.002)
        self.create_circuit_network('PSTN1', 180, 0.002)
        self.create_package_network('IP1', 12000, 0, 18000, 0, 1500)
        self.create_package_network('IP2', 16000, 0, 20000, 0, 1500)
        self.create_package_network('IP1', 15000, 0, 19000, 0, 1500)


        self.set_interest_matrix_voice([[0, 0.2, 0.2, 0.2, 0.2, 0.2],
                                        [0.2, 0, 0.2, 0.2, 0.2, 0.2],
                                        [0.2, 0.2, 0, 0.2, 0.2, 0.2],
                                        [0.2, 0.2, 0.2, 0, 0.2, 0.2],
                                        [0.2, 0.2, 0.2, 0.2, 0, 0.2],
                                        [0.2, 0.2, 0.2, 0.2, 0.2, 0]])
        #self.set_interest_matrix_video([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0],
        #                                [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]])

        self.set_interest_matrix_be([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0],
                                     [0, 0, 0, 0, 0.5, 0.5], [0, 0, 0, 0.5, 0, 0.5], [0, 0, 0, 0.5, 0.5, 0]])

        self.process_data_resources()

        self.create_node_edge('RB1', 5, 15, 30)
        self.create_node_edge('RB2', 5, 15, 30)
        self.create_node_edge('RB3', 5, 15, 30)
        self.create_node_edge('RB4', 5, 15, 30)
        self.create_node_edge('RB5', 5, 15, 30)
        self.create_node_edge('RB6', 5, 15, 30)
        for abc in range(7):
            if abc > 0:
                self.create_node_core('RR' + str(abc), 5, 15, 30)

        self.create_adjacency_matrix([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],   # 0 rb
                                      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0],   # 1 rb
                                      [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],   # 2 rb
                                      [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],   # 3 rb
                                      [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],   # 4 rb
                                      [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],   # 5 rb
                                      [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0],   # 6 rr
                                      [0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1],   # 7 rr
                                      [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0],   # 8 rr
                                      [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],   # 9 rr
                                      [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0]])  # 10 rr

        #d.create_links()
        self.create_links()
        c = 150000000
        for link in self.links:
                self.edit_link('', self.links.index(link), 40, c)

        self.create_paths_matrix_voice([[0, 6, 7, 10, 2], [2, 10, 7, 6, 0], [0, 6, 3], [3, 6, 0], [0, 6, 4], [4, 6, 0],
                                        [0, 6, 7, 8, 5], [5, 8, 7, 6, 0], [1, 8, 7, 6, 0], [0, 6, 7, 8, 1],
                                        [1, 8, 2], [2, 8, 1], [2, 8, 5], [5, 8, 2], [4, 10, 7, 8, 5], [5, 8, 7, 10, 4],
                                        [1, 8, 5], [5, 8, 1], [3, 6, 4], [4, 6, 3], [3, 9, 7, 8, 5], [5, 8, 7, 9, 3]])

        self.create_paths_matrix_video([[0, 6, 7, 10, 2], [2, 10, 7, 6, 0], [0, 6, 3], [3, 6, 0], [0, 6, 4], [4, 6, 0],
                                        [0, 6, 7, 2, 5], [5, 2, 7, 6, 0], [1, 8, 7, 6, 0], [0, 6, 7, 8, 1],
                                        [1, 8, 2], [2, 8, 1], [2, 8, 5], [5, 8, 2], [4, 10, 7, 8, 5], [5, 8, 7, 10, 4],
                                        [1, 8, 5], [5, 8, 1], [3, 6, 4], [4, 6, 3], [3, 9, 7, 8, 5], [5, 8, 7, 9, 3]])

        #self.create_paths_matrix_be([[0, 6, 7, 10, 2], [2, 10, 7, 6, 0], [0, 6, 3], [3, 6, 0], [0, 6, 4], [4, 6, 0],
        #                             [0, 6, 7, 2, 5], [5, 2, 7, 6, 0], [1, 8, 7, 6, 0], [0, 6, 7, 8, 1],
        #                             [1, 8, 2], [2, 8, 1], [2, 8, 5], [5, 8, 2], [4, 10, 7, 8, 5], [5, 8, 7, 10, 4],
        #                             [1, 8, 5], [5, 8, 1], [3, 6, 4], [4, 6, 3], [3, 9, 7, 8, 5], [5, 8, 7, 9, 3]])

        self.create_paths_matrix_be([[3, 6, 4], [3, 9, 7, 8, 5], [4, 6, 3], [4, 10, 7, 8, 5],
                                     [5, 8, 7, 9, 3], [5, 8, 7, 10, 4]])

        self.create_net_edge_matrix([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5]])
        self.set_connections()

        self.scatter_flow_voice()
        #self.scatter_flow_video()
        self.scatter_flow_be()

        self.sum_up_flow()

        print('Natezenie dla sieci 0 ', self.networks[3].flow_be_in_list)
        print('Natezenie dla sieci 5 ', self.networks[5].flow_voice_in_list)
        print('Voice package length: ', self.avg_voice_package_length)

        #for link in self.links:
            #print('Voice in link {}'.format(link.name), link.paths_voice)
            #print(link.paths_voice)
            #print(link.iplr_voice)
            #print(link.ipdt_voice)
            #print(link.ipdv_voice)

        self.scatter_iplr()
        self.sum_iplr_path_voice()
        self.sum_iplr_path_video()
        self.sum_iplr_path_be()
        #
        self.scatter_ipdt()
        self.sum_ipdt_path_voice()
        self.sum_ipdt_path_video()
        self.sum_ipdt_path_be()
        #
        self.scatter_ipdv()
        self.sum_ipdv_path_voice()
        self.sum_ipdv_path_video()
        self.sum_ipdv_path_be()


        print('xxxxxxxxxxxxx PATHS xxxxxxxxxxxxx')
        for x in self.iplr_for_paths_voice:
            print(x, self.iplr_for_paths_voice[x])
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        for x in self.ipdt_for_paths_voice:
            print(x, self.ipdt_for_paths_voice[x])
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        for x in self.ipdv_for_paths_voice:
            print(x, self.ipdv_for_paths_voice[x])
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        print('xxxxxxxxxxxxx LINKS xxxxxxxxxxxxxxx')
        for link in self.links:
            print('IPLR {}: {}'.format(link.name, link.iplr_voice))
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        for link in self.links:
            print('IPDT {}: {}'.format(link.name, link.ipdt_voice))
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        for link in self.links:
            print('IPDV {}: {}'.format(link.name, link.ipdv_voice))
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        print('xxxxxxxxxxxxx BE xxxxxxxxxxxxxx')
        for link in self.links:
            print('IPLR {}: {}'.format(link.name, link.iplr_be))
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        for link in self.links:
            print('IPDT {}: {}'.format(link.name, link.ipdt_be))
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        for link in self.links:
            print('IPDV {}: {}'.format(link.name, link.ipdv_be))
        print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

        print('xxxxxxxxxxxxx Voice xxxxxxxxxxxxxxxx')
        for link in self.links:
            print('Flow voice {}: {}'.format(link.name, link.paths_voice))

        print('xxxxxxxxxxxxx BE xxxxxxxxxxxxxxxx')
        for link in self.links:
            print('Flow be {}: {}'.format(link.name, link.paths_be))


if __name__ == '__main__':

    d = Data()

    d.test3()