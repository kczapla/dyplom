__author__ = 'perun'

import networkx as nx
import core.networks as nw
import core.test as test


class Data:
    def __init__(self):
        """
        Method initialize interests matrix for 3 class of flow, list of creted by user networks and index to handle
        operations on networks.

        """
        self.interest_matrix_voice = []
        self.interest_matrix_video = []
        self.interest_matrix_be = []
        self.networks = []
        self.index = 0

#Methods connected with displaying Data class
    def process_data(self):

        for nets in self.networks:
            nets.reset_resources()

        self.split_matrix()

        if self.interest_matrix_voice:
            for nets in self.networks:
                if 'GSM' in nets.name:
                    nets.set_intensity_voice_out(self.networks)

            for nets in self.networks:
                if 'GSM' in nets.name:
                    nets.input_resources()
                    nets.output_resources()

            for nets in self.networks:
                nets.set_flow_voice_in(self.networks)

            for nets in self.networks:
                nets.set_flow_voice_out(self.networks)

        for nets in self.networks:
            if not 'GSM' in nets.name:
                if self.interest_matrix_video:
                    nets.set_flow_video_in(self.networks)
                if self.interest_matrix_be:
                    nets.set_flow_be_in(self.networks)

        for nets in self.networks:
            if not 'GSM' in nets.name:
                if self.interest_matrix_video:
                    nets.set_flow_video_out(self.networks)
                if self.interest_matrix_be:
                    nets.set_flow_be_out(self.networks)

    def show_data(self):
        for x in self.networks:
            print("+++++++++++++++++")
            for y in (x.__dict__.keys()):
                print("{} = {}".format(y, x.__dict__[y]))
            print("+++++++++++++++++")

    def use_test_values(self):
        self.interest_matrix_voice = test.interest_matrix
        self.interest_matrix_video = test.intrest_matrix_video
        self.interest_matrix_be = test.interest_matrix_be
        for tmp in test.test_networks():
            self.networks.append(tmp)
            self.index = test.index

#Methods connected with processing Data class
    def create_circuit_network(self, intensity=0, loss=0):

        """
        Method is adding new circuit network, with values set by user, to the row of networks
        :param intensity: Intensity generated by network
        :param loss: loss probability
        """
        self.networks.append(nw.Circuit(self.index, intensity, loss))
        self.index += 1

    def create_package_network(self, intensity_voice=0, intensity_video=0, intensity_be=0):

        """
        Method is adding new package network, with values set by user, to the row of networks
        :param intensity_video: Video stream intensity generated by network
        :param intensity_be: BE stream intensity generated by network
        :param intensity_voice: Voice stream intensity generated by network
        """

        self.networks.append(nw.Package(self.index, intensity_voice, intensity_video, intensity_be))
        self.index += 1

    def delete_network(self, n=None):

        """
        Method is deleting selected network from the row of created networks. It also removes the row from an interest
        matrix belonging to deleted network. Finally it reorganise index of existing networks and reprocess data.
        :param n: Index of network to delete
        """
        self.networks.pop(n)
        self.index -= 1

        for x in range(self.index):
            self.networks[x].set_index(x)

            if self.interest_matrix_voice:
                self.interest_matrix_voice[x].pop(n)
            if self.interest_matrix_video:
                self.interest_matrix_video[x].pop(n)
            if self.interest_matrix_be:
                self.interest_matrix_be[x].pop(n)

            if self.interest_matrix_voice:
                self.interest_matrix_voice.pop(n)

            if self.interest_matrix_video:
                self.interest_matrix_video.pop(n)
            if self.interest_matrix_be:
                self.interest_matrix_be.pop(n)

    def create_interest_matrix(self, interest_matrix=None):
        """
        Creating the interest matrix based on the number of networks
        """
        interest_matrix = []
        for ly in range(self.index):
            interest_matrix.append(
                [float(input('x[{}][{}] = '.format(ly, lx))) for lx in range(self.index)])

    def split_matrix(self):
        """
        Method which partial interest matrix into row to every network
        :return: set the value of interest_row_voice in instance of the network class
        """
        for temp in self.networks:
            if self.interest_matrix_voice:
                temp.interest_row_voice = self.interest_matrix_voice[temp.index]

            if self.interest_matrix_video:
                temp.interest_row_video = self.interest_matrix_video[temp.index]

            if self.interest_matrix_be:
                temp.interest_row_be = self.interest_matrix_be[temp.index]

    def change_single_value_matrix(self, row, col, interest_matrix=None):
        interest_matrix[row][col] = float(input('New value: '))


if __name__ == '__main__':
    pass